package colorCreator;

import javax.swing.*;
import java.awt.*;

/**
 * Created by adani14 on 2/7/2017.
 */
public class MonochromeSwatch implements Swatch {

    Color baseColor;
    Color colors[];

    /**
     * Default constructor, unsued for now. Not sure if I need it?
     */
    public MonochromeSwatch(){

    }

    /*
     * Getters and Setters
     */
    public Color getBaseColor(){
        return baseColor;
    }

    public void setBaseColor(Color c){

        baseColor = c;
    }

    /**
     * This is the constructor I intend to use for the most part, takes in the number of
     * colors, whether or not the colors should be complementary, and eventually whether or not
     * the palette will be pastel.
     * @param numColors the number of colors the user wants.
     */
    public MonochromeSwatch(int numColors){


        /*
         *  Ask the user if they want a random color or if they have a base color in mind.
         * - If they don't have a color in mind, run random color chooser.
         *  - Ask if they like the chosen color. (Not currently implemented, needs a new method)
         *  - If no, re-run the random color chooser.
         * -If they do have a color in mind, have them input the color.
         * Check complementary. If true, then disregard numColors, run complementaryColors. (depreciated)
         * If false, run createColors.
         *
         */

        //A message dialog here, or whatever, I'll get to it later. The choice will be stored in int choice.
        boolean odd = isOdd(numColors);
        float factor = 0;
        JFrame frame = new JFrame();
        frame.setLocationRelativeTo(null);
        frame.setAlwaysOnTop(true);
        colors = new Color[numColors + 1];
        for(int i = 0; i < colors.length; i++){
            colors[i] = Color.BLACK;
        }

            /*
             * Give the user a choice of entering a hexcode or a RGB value.
             */
        	int opt;
            String options[] = {"Yes", "No"};
            opt = JOptionPane.showOptionDialog(frame, "Do you have a color in mind as your base color?", "Base color",
                    JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, options, options[0]);
            
            switch(opt){
            
            	case 0:
            	    baseColor = chooseColor();
            	    if(baseColor == null){
            	        return;
                    }
            		break;
            	case 1:
            		baseColor = randomColorChooser();
                    if(baseColor == null){
                        return;
                    }
            		break;
        		default:
        			baseColor = randomColorChooser();
                    if(baseColor == null){
                        return;
                    }
        			break;
            
            }
            
            JOptionPane.showMessageDialog(frame, "Your base color is " + decimaltoHex(baseColor.getRed(),
            		baseColor.getGreen(), baseColor.getBlue()));

            factor = getFactor();

            if(odd){
                colors = divisionOfColors(numColors, baseColor, factor);
            }
            else{
                /*
                 * This needs to ask about whether the user wants equal tints and shades or more tints
                 * or more shades.
                 */
                colors = createColors(baseColor, numColors, factor);
            }



    }

    /**
     * This method needs a rewrite.
     *
     * This method prints out a string. The string prints out the colors created by this class
     * in hexadecimal. It also prints the base color on a separate line.
     *
     * @return information a string with all of the colors generated by this class
     */
    public String toString(){
    	
    	String information = "Colors: ";
    	boolean printed = false;
    	String repeatedColors = "";

    	if(baseColor == null){
    	    return "There's no baseColor, so a swatch cannot be generated.";
        }
        else if(colors == null){
            return "There is no generated swatch.";
        }
    	else {
            for (int i = 0; i < colors.length; i++) {

                information = information + " " + colorToHex(colors[i]) + " ";
            /*
             * This is supposed to remove repeating colors...
             *
             * but doing something like color[1] = color[2] doesn't work.
             * I need to figure out what to do to fix that, but this code only semi works,
             * it doesn't work for leading repeating values, like 000000? It won't do it.
             */
            /*if(i == 0){
                information = information + " " + colorToHex(colors[i]) + " ";
            }
    	    else if(i != 0 && i + 1 < colors.length){
                if(colors[i + 1] == colors[i]){
                    repeatedColors = repeatedColors + "Color " + colorToHex(colors[i]) + "repeated.\n";
                }
    	        if(colors[i + 1] != colors[i]) {
                    if(printed == false){
                        information = information + " " + colorToHex(colors[i]) + " ";
                    }
                    else {
                        repeatedColors = repeatedColors + "Color " + colorToHex(colors[i]) + "repeated.\n";
                    }
                }
            }
            else if(i == colors.length - 1 && colors[i].getRGB() == colors[i - 1].getRGB()){
                repeatedColors = repeatedColors + "Color " + colorToHex(colors[i]) + "repeated.\n";
            }*/
            }

            information = information + "\nBase Color: " + colorToHex(baseColor) + "\n" + repeatedColors;
        }
    	
    	
    	return information;
    }

    @Override
    public void swap(Color[] swatch, int init, int fin) {

        /*
         *
         * OK, for monochrome, this might actually be pretty easy... I'll just use
         * brightenBy and darkenBy.
         *
         * 1) Save first color in a temp. variable, we'll call that start or something.
         * get HSL value, we're focusing on lightness.
         *
         * Compare the lightness of start to the lightness of the next value.
         *
         * THE HIGHER THE LIGHTNESS, THE BRIGHTER THE COLOR. Therefore: if the L value of
         * a color is lower than start, move it closer to the 0 value. If the L value of a
         * color is HIGHER than start, don't move start and switch the value of start to the
         * new value.
         *
         */

        Color start;
        Color saveTemp;
        float[] startValue;


        //OK, so here we go.
        for(int k = 0; k < swatch.length; k++) {

            start = swatch[k];
            //Lightness is StartValue[5]
            startValue = getHSV(start);
            int i = k + 1;

            if(i < swatch.length) {
                do {
                    float[] tempValue = getHSV(swatch[i]);

                    if (startValue[5] > tempValue[5]) {
                        saveTemp = swatch[i];
                        start = swatch[k];

                        swatch[k] = saveTemp;
                        swatch[i] = start;


                    }

                    i++;
                }
                while (i < swatch.length);
            }

        }

    }
}
